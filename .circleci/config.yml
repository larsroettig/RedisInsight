version: 2.1

aliases:
  keychain: &keychain
    run:
      name: Add cert to the keychain
      command: |
        security create-keychain -p mysecretpassword $KEYCHAIN
        security default-keychain -s $KEYCHAIN
        security unlock-keychain -p mysecretpassword $KEYCHAIN
        security import certs/cert.p12 -k $KEYCHAIN -P "$CSC_KEY_PASSWORD" -T /usr/bin/codesign
        security set-key-partition-list -S apple-tool:,apple: -s -k mysecretpassword $KEYCHAIN
      environment:
        KEYCHAIN: redisinsight.keychain
  import: &import
    run:
      name: User certutil to import certificate
      command: certutil -p %WIN_CSC_KEY_PASSWORD% -importpfx certs\redislabs_win.pfx
      shell: cmd.exe
  sign: &sign
    run:
      name: Sign application
      command: |
        $filePath = $(Get-ChildItem release -Filter RedisInsight*.exe | % { $_.FullName })
        $filePathWithQuotes = '"{0}"' -f $filePath
        & "C:\Program Files (x86)\Windows Kits\10\bin\10.0.19041.0\x86\signtool.exe" sign /a /sm /n "Redis Labs Inc." /fd sha256 /tr http://sha256timestamp.ws.symantec.com/sha256/timestamp /v $FilePathWithQuotes
      shell: powershell.exe
  scan: &scan
    run:
      name: Virustotal scan
      command: &virusscan |
        uploadUrl=$(curl -sq -XGET https://www.virustotal.com/api/v3/files/upload_url -H "x-apikey: $VIRUSTOTAL_API_KEY" | jq -r '.data')
        uploadFile=$("/usr/bin/find" /tmp/release -name ${FILE_NAME})
        echo "File to upload: ${uploadFile}"
        analysedId=$(curl -sq -XPOST "${uploadUrl}" -H "x-apikey: $VIRUSTOTAL_API_KEY" --form file=@"${uploadFile}" | jq -r '.data.id')
        if [ $analysedId == "null" ]; then
          echo 'Status is null, something went wrong'; exit 1;
        fi
        echo "export ANALYZED_ID=${analysedId}" >> $BASH_ENV
        echo "Virustotal Analyzed id: ${analysedId}"
        sleep 10
      shell: /bin/bash
  validate: &validate
    run:
      name: Virustotal validate scan results
      command: &virusValidate |
        analyzeStatus=$(curl -sq -XGET https://www.virustotal.com/api/v3/analyses/${ANALYZED_ID} -H "x-apikey: $VIRUSTOTAL_API_KEY" | jq -r '.data.attributes.status')
        if [ $analyzeStatus == "null" ]; then
          echo 'Status is null, something went wrong'; exit 1;
        fi

        currentOperation="50"
        until [ "$currentOperation" == "0" ]; do
          if [ "$analyzeStatus" == "completed" ]
          then
            echo "Current status: ${analyzeStatus}"; break;
          else
            echo "Current status: ${analyzeStatus}, retries left: ${currentOperation} ";
            analyzeStatus=$(curl -sq -XGET https://www.virustotal.com/api/v3/analyses/${ANALYZED_ID} -H "x-apikey: $VIRUSTOTAL_API_KEY" | jq -r '.data.attributes.status');
            sleep 20;
            currentOperation=$[$currentOperation - 1];
          fi
        done

        analyzeStats=$(curl -sq -XGET https://www.virustotal.com/api/v3/analyses/${ANALYZED_ID} -H "x-apikey: $VIRUSTOTAL_API_KEY" | jq -r '.data.attributes.stats')
        analazedHarmless=$(echo ${analyzeStats} | jq '.harmless')
        analazedMalicious=$(echo ${analyzeStats} | jq '.malicious')
        analazedSuspicious=$(echo ${analyzeStats} | jq '.suspicious')

        if [ "$analyzeStatus" != "completed" ]; then
          echo 'Analyse is not completed'; exit 1;
        fi
        echo "Results:"
        echo "analazedHarmless: ${analazedHarmless}, analazedMalicious:  ${analazedMalicious}, analazedSuspicious: ${analazedSuspicious}"

        if [ "$analazedHarmless" != "0" ] || [ "$analazedMalicious" != "0" ] || [ "$analazedSuspicious" != "0" ]; then
          echo 'Found dangers'; exit 1;
        fi

        echo 'Passed';
      shell: /bin/bash
      no_output_timeout: 15m
  iTestsNames: &iTestsNames
    - oss-st-5            # OSS Standalone v5
    - oss-st-5-pass       # OSS Standalone v5 with admin pass required
    - oss-st-6            # OSS Standalone v6 and all modules
    #- mods-preview        # OSS Standalone and all preview modules // todo: uncomment after broken image will be fixed
    - oss-st-6-tls        # OSS Standalone v6 with TLS enabled
    - oss-st-6-tls-auth   # OSS Standalone v6 with TLS auth required
    - oss-clu             # OSS Cluster
    - oss-clu-tls         # OSS Cluster with TLS enabled
    - oss-sent            # OSS Sentinel
    - re-st               # Redis Enterprise with Standalone inside
    - re-clu              # Redis Enterprise with Cluster inside
  dev-filter: &devFilter
    filters:
      branches:
        only:
          - main
          - main-build
  stage-filter: &stageFilter
    filters:
      branches:
        only:
          - /^release.*/
  prod-filter: &prodFilter
    filters:
      branches:
        only:
          - latest
  ui-deps-cache-key: &uiDepsCacheKey
    key: v1-ui-deps-{{ checksum "yarn.lock" }}
  api-deps-cache-key: &apiDepsCacheKey
    key: v1-ui-deps-{{ checksum "redisinsight/api/yarn.lock" }}

orbs:
  win: circleci/windows@2.4.0
  node: circleci/node@4.4.0
  aws: circleci/aws-cli@2.0.3

executors:
  linux-executor:
    machine:
      image: ubuntu-2004:202010-01

jobs:
  # Test jobs
  unit-tests-ui:
    docker:
      - image: circleci/node:15.14.0
    steps:
      - checkout
      - restore_cache:
          <<: *uiDepsCacheKey
      - run:
          name: UI PROD dependencies audit
          command: |
            FILENAME=ui.prod.deps.audit.json
            yarn audit --groups dependencies --json > $FILENAME || true &&
            FILENAME=$FILENAME DEPS="UI prod" node .circleci/deps-audit-report.js &&
            curl -H "Content-type: application/json" --data @slack.$FILENAME -H "Authorization: Bearer ${SLACK_AUDIT_REPORT_KEY}" -X POST https://slack.com/api/chat.postMessage
      - run:
          name: UI DEV dependencies audit
          command: |
            FILENAME=ui.dev.deps.audit.json
            yarn audit --groups devDependencies --json > $FILENAME || true &&
            FILENAME=$FILENAME DEPS="UI dev" node .circleci/deps-audit-report.js &&
            curl -H "Content-type: application/json" --data @slack.$FILENAME -H "Authorization: Bearer ${SLACK_AUDIT_REPORT_KEY}" -X POST https://slack.com/api/chat.postMessage
      - run:
          name: Code analysis
          command: |
            SKIP_POSTINSTALL=1 yarn install

            FILENAME=ui.lint.audit.json
            WORKDIR="."
            yarn lint:ui -f json -o $FILENAME || true &&
            FILENAME=$FILENAME WORKDIR=$WORKDIR TARGET="UI" node .circleci/lint-report.js &&
            curl -H "Content-type: application/json" --data @$WORKDIR/slack.$FILENAME -H "Authorization: Bearer ${SLACK_AUDIT_REPORT_KEY}" -X POST https://slack.com/api/chat.postMessage

            FILENAME=rest.lint.audit.json
            yarn lint -f json -o $FILENAME || true &&
            FILENAME=$FILENAME WORKDIR=$WORKDIR TARGET="REST" node .circleci/lint-report.js &&
            curl -H "Content-type: application/json" --data @$WORKDIR/slack.$FILENAME -H "Authorization: Bearer ${SLACK_AUDIT_REPORT_KEY}" -X POST https://slack.com/api/chat.postMessage
      - run:
          name: Unit tests UI
          command: |
            yarn test:cov --ci
      - save_cache:
          <<: *uiDepsCacheKey
          paths:
            - ./node_modules
  unit-tests-api:
    docker:
      - image: circleci/node:15.14.0
    steps:
      - checkout
      - restore_cache:
          <<: *apiDepsCacheKey
      - run:
          name: API PROD dependencies scan
          command: |
            FILENAME=api.prod.deps.audit.json
            yarn --cwd redisinsight/api audit --groups dependencies --json > $FILENAME || true &&
            FILENAME=$FILENAME DEPS="API prod" node .circleci/deps-audit-report.js &&
            curl -H "Content-type: application/json" --data @slack.$FILENAME -H "Authorization: Bearer ${SLACK_AUDIT_REPORT_KEY}" -X POST https://slack.com/api/chat.postMessage
      - run:
          name: API DEV dependencies scan
          command: |
            FILENAME=api.dev.deps.audit.json
            yarn --cwd redisinsight/api audit --groups devDependencies --json > $FILENAME || true &&
            FILENAME=$FILENAME DEPS="API dev" node .circleci/deps-audit-report.js &&
            curl -H "Content-type: application/json" --data @slack.$FILENAME -H "Authorization: Bearer ${SLACK_AUDIT_REPORT_KEY}" -X POST https://slack.com/api/chat.postMessage
      - run:
          name: Code analysis
          command: |
            yarn --cwd redisinsight/api

            FILENAME=api.lint.audit.json
            WORKDIR="./redisinsight/api"
            yarn lint:api -f json -o $FILENAME || true &&
            FILENAME=$FILENAME WORKDIR=$WORKDIR TARGET="API" node .circleci/lint-report.js &&
            curl -H "Content-type: application/json" --data @$WORKDIR/slack.$FILENAME -H "Authorization: Bearer ${SLACK_AUDIT_REPORT_KEY}" -X POST https://slack.com/api/chat.postMessage
      - run:
          name: Unit tests API
          command: |
            yarn --cwd redisinsight/api/ test:cov --ci
      - save_cache:
          <<: *apiDepsCacheKey
          paths:
            - ./redisinsight/api/node_modules
  integration-tests-run:
    executor: linux-executor
    parameters:
      rte:
        description: Redis Test Environment name
        type: string
      build:
        description: Backend build to run tests over
        type: enum
        default: local
        enum: ['local', 'docker', 'saas']
      report:
        description: Send report for test run to slack
        type: boolean
        default: false
    steps:
      - checkout
      - restore_cache:
          <<: *apiDepsCacheKey
      - when:
          condition:
            equal: [ 'docker', << parameters.build >> ]
          steps:
            - attach_workspace:
                at: /tmp
            - run:
                name: Load built docker image from workspace
                command: |
                  docker image load -i /tmp/docker-release/docker.tar
      - run:
          name: Run tests
          command: |
            ./redisinsight/api/test/test-runs/start-test-run.sh -r << parameters.rte >> -t << parameters.build >>
            mkdir -p mkdir itest/coverages && mkdir -p itest/results
            cp ./redisinsight/api/test/test-runs/coverage/test-run-result.json ./itest/results/<< parameters.rte >>.result.json
            cp ./redisinsight/api/test/test-runs/coverage/test-run-result.xml ./itest/results/<< parameters.rte >>.result.xml
            cp ./redisinsight/api/test/test-runs/coverage/test-run-coverage.json ./itest/coverages/<< parameters.rte >>.coverage.json
      - when:
          condition:
            equal: [ true, << parameters.report >> ]
          steps:
            - run:
                name: Send report
                when: always
                command: |
                  ITEST_NAME=<< parameters.rte >> node ./.circleci/itest-results.js
                  curl -H "Content-type: application/json" --data @itests.report.json -H "Authorization: Bearer $SLACK_TEST_REPORT_KEY" -X POST https://slack.com/api/chat.postMessage
      - store_test_results:
          path: ./itest/results
      - persist_to_workspace:
          root: .
          paths:
            - ./itest/results/<< parameters.rte >>.result.json
            - ./itest/coverages/<< parameters.rte >>.coverage.json
  integration-tests-coverage:
    executor: linux-executor
    steps:
      - checkout
      - attach_workspace:
          at: /tmp
      - run:
          name: Calculate coverage across all tests runs
          command: |
            sudo mkdir -p /usr/src/app
            sudo cp -a ./redisinsight/api/. /usr/src/app/
            sudo cp -R /tmp/itest/coverages /usr/src/app && sudo chmod 777 -R /usr/src/app
            cd /usr/src/app && npx nyc report -t ./coverages -r text -r text-summary
  e2e-tests:
    executor: linux-executor
    parameters:
      build:
        description: Backend build to run tests over
        type: enum
        default: local
        enum: ['local', 'docker']
      report:
        description: Send report for test run to slack
        type: boolean
        default: false
    steps:
      - checkout
      - when:
          condition:
            equal: [ 'docker', << parameters.build >> ]
          steps:
            - attach_workspace:
                at: /tmp
            - run:
                name: Load built docker image from workspace
                command: |
                  docker image load -i /tmp/docker-release/docker.tar
            - run:
                name: Run tests
                command: |
                  docker-compose -f tests/e2e/docker-compose.yml -f tests/e2e/docker.docker-compose.yml up --abort-on-container-exit
                no_output_timeout: 5m
      - when:
          condition:
            equal: [ 'local', << parameters.build >> ]
          steps:
            - run:
                name: Run tests
                command: |
                  docker-compose -f tests/e2e/docker-compose.yml up --abort-on-container-exit
                no_output_timeout: 5m
      - when:
          condition:
            equal: [ true, << parameters.report >> ]
          steps:
            - run:
                name: Send report
                when: always
                command: |
                  node ./.circleci/e2e-results.js
                  curl -H "Content-type: application/json" --data @e2e.report.json -H "Authorization: Bearer $SLACK_TEST_REPORT_KEY" -X POST https://slack.com/api/chat.postMessage

  # Build jobs
  setup-sign-certificates:
    executor: linux-executor
    steps:
      - run:
          name: Setup sign certificates
          command: |
            mkdir -p certs
            echo "$CSC_P12_HEX" | xxd -r -p > certs/cert.p12
            echo "$WIN_CSC_PFX_HEX" | xxd -r -p > certs/redislabs_win.pfx
      - persist_to_workspace:
          root: .
          paths:
            - certs
  setup-build:
    parameters:
      env:
        description: Build environemtnt (stage || prod)
        type: enum
        default: stage
        enum: [ 'dev', 'stage', 'prod' ]
    docker:
      - image: cibuilds/github:0.13
    steps:
      - checkout
      - run:
          command: |
            mkdir electron

            CURRENT_VERSION=$(jq -r ".version" redisinsight/package.json)
            echo "Version: ${CURRENT_VERSION}"

            if [ << parameters.env >> == "prod" ]; then
              echo "Build version: $CURRENT_VERSION"
              cp ./redisinsight/package.json ./electron/package.json
              exit 0
            fi

            if [ << parameters.env >> == "dev" ]; then
              VERSION=$CURRENT_VERSION-dev-$CIRCLE_BUILD_NUM
              echo "Build version: $VERSION"
              echo $(jq ".version=\"$VERSION\"" redisinsight/package.json) > electron/package.json
              exit 0
            fi

            CURRENT_RC_TAG=$(git tag --points-at $CIRCLE_SHA1 --sort=-v:refname -l "$CURRENT_VERSION"-rc* | head -1)
            echo "Current RC tag: $CURRENT_RC_TAG"

            VERSION="$CURRENT_VERSION"-rc1
            if [[ "$CURRENT_RC_TAG" == "" ]]
            then
              LATEST_RC_TAG=$(git tag --sort=-refname -l "$CURRENT_VERSION"-rc* | head -1)
              echo "Latest RC tag: $LATEST_RC_TAG"

              if [[ "$LATEST_RC_TAG" == "" ]]
              then
                echo "new version: $VERSION"
                # ghr -t ${GH_TOKEN} -u ${CIRCLE_PROJECT_USERNAME} -r ${CIRCLE_PROJECT_REPONAME} -c ${CIRCLE_SHA1} -prerelease -delete ${VERSION}
              else
                echo "Trying to get RC number from LATEST_RC_TAG: $LATEST_RC_TAG"
                RC_NUMBER=$(echo "$LATEST_RC_TAG" | sed -r 's/.*[^0-9]+([0-9]*)$/\1/')
                NEW_RC_NUMBER=$(("$RC_NUMBER" + 1))
                echo "Trying increase RC number: $RC_NUMBER -> $NEW_RC_NUMBER"
                VERSION=$(echo "$LATEST_RC_TAG" | sed -e "s/$RC_NUMBER$/$NEW_RC_NUMBER/g")
                # ghr -t ${GH_TOKEN} -u ${CIRCLE_PROJECT_USERNAME} -r ${CIRCLE_PROJECT_REPONAME} -c ${CIRCLE_SHA1} -prerelease -delete ${VERSION}
              fi
            else
              echo "rc4 CURRENT! $CURRENT_RC_TAG"
              VERSION=$CURRENT_RC_TAG
            fi

            echo "Build version: $VERSION"
            echo $(jq ".version=\"$VERSION\"" redisinsight/package.json) > electron/package.json
      - persist_to_workspace:
          root: /root/project
          paths:
            - electron
  linux:
    docker:
      - image: circleci/node:15.14.0
    resource_class: large
    parameters:
      env:
        description: Build environment (stage || prod)
        type: enum
        default: stage
        enum: ['stage', 'prod']
    steps:
      - checkout
      - attach_workspace:
          at: .
      - run:
          command: |
            cp ./electron/package.json ./redisinsight/
      - run:
          name: install dependencies
          command: |
            yarn --cwd redisinsight/api/ install
            yarn install
            yarn build:statics
          no_output_timeout: 15m
      - run:
          name: Build linux AppImage and deb
          command: |
            if [ << parameters.env >> == 'prod' ]; then
              yarn package:prod
              exit 0;
            fi

            UPGRADES_LINK=$UPGRADES_LINK_STAGE SEGMENT_WRITE_KEY=MWGOG146oPdLSWO5mZy3eM1NzcC3alRF yarn package:<< parameters.env >>
      - persist_to_workspace:
          root: .
          paths:
            - release/RedisInsight*.deb
            - release/RedisInsight*.AppImage
            - release/*-linux.yml
  macosx:
    macos:
      xcode: 11.3.0
    parameters:
      env:
        description: Build environment (stage || prod)
        type: enum
        default: stage
        enum: ['stage', 'prod']
    steps:
      - checkout
      - node/install:
          node-version: '15.14.0'
      - attach_workspace:
          at: .
      - run:
          command: |
            cp ./electron/package.json ./redisinsight/
      - run:
          name: install dependencies
          command: |
            yarn install
            yarn --cwd redisinsight/api/ install
            yarn build:statics
          no_output_timeout: 15m
      - <<: *keychain
      - run:
          name: Build macos dmg
          command: |
            if [ << parameters.env >> == 'prod' ]; then
              yarn package:prod
              rm -rf release/mac
              exit 0;
            fi

            UPGRADES_LINK=$UPGRADES_LINK_STAGE SEGMENT_WRITE_KEY=MWGOG146oPdLSWO5mZy3eM1NzcC3alRF yarn package:<< parameters.env >>
            rm -rf release/mac
          no_output_timeout: 15m
      - persist_to_workspace:
          root: .
          paths:
            - release/RedisInsight*.zip
            - release/RedisInsight*.dmg
            - release/RedisInsight*.dmg.blockmap
            - release/*-mac.yml
  windows:
    executor:
      name: win/default
    parameters:
      env:
        description: Build environment (stage || prod)
        type: enum
        default: stage
        enum: ['stage', 'prod']
    steps:
      - checkout
      - attach_workspace:
          at: .
      - run:
          command: |
            cp ./electron/package.json ./redisinsight/
      - run:
          name: Build windows exe
          command: |
            choco install nodejs --version=15.14.0
            # set ALL_REDIS_COMMANDS=$(curl $ALL_REDIS_COMMANDS_RAW_URL)
            yarn install
            yarn --cwd redisinsight/api/ install
            yarn build:statics:win
            if [ << parameters.env >> == 'prod' ]; then
              yarn package:prod
              rm -rf release/win-unpacked
              exit 0;
            fi

            UPGRADES_LINK=$UPGRADES_LINK_STAGE SEGMENT_WRITE_KEY=MWGOG146oPdLSWO5mZy3eM1NzcC3alRF yarn package:<< parameters.env >>
            rm -rf release/win-unpacked
          shell: bash.exe
          no_output_timeout: 20m
      - persist_to_workspace:
          root: .
          paths:
            - release/RedisInsight*.exe
            - release/RedisInsight*.exe.blockmap
            - release/*.yml
  virustotal:
    executor: linux-executor
    parameters:
      ext:
        description: File extension
        type: string
    steps:
      - checkout
      - attach_workspace:
          at: /tmp/release
      - run:
          name: export FILE_NAME environment variable
          command: |
            echo 'export FILE_NAME="RedisInsight*.<< parameters.ext >>"' >> $BASH_ENV
      - <<: *scan
      - <<: *validate
  docker:
    executor: linux-executor
    parameters:
      env:
        type: enum
        default: staging
        enum: ['staging', 'production']
    steps:
      - checkout
      - run:
          name: Build Docker image (API + UI)
          command: |
            docker build --build-arg NODE_ENV=<< parameters.env >> --build-arg SERVER_TLS_CERT="$SERVER_TLS_CERT" --build-arg SERVER_TLS_KEY="$SERVER_TLS_KEY" -t riv2:latest .
            mkdir -p docker-release
            docker image save -o docker-release/docker.tar riv2
      - persist_to_workspace:
          root: .
          paths:
            - ./docker-release

  # Release jobs
  store-build-artifacts:
    executor: linux-executor
    steps:
      - attach_workspace:
          at: .
      - store_artifacts:
          path: release
          destination: release
  release-github:
    parameters:
      env:
        description: Release environment (stage || prod)
        type: enum
        default: stage
        enum: [ 'stage', 'prod' ]
    docker:
      - image: cibuilds/github:0.13
    steps:
      - checkout
      - attach_workspace:
          at: .
      - store_artifacts:
          path: release
          destination: release
      - run:
          name: prepare release
          command: |
            rm release/._* ||:
      - run:
          name: publish to prerelease Github
          command: |
            applicationVersion=$(jq -r '.version' electron/package.json)
            echo "APP VERSION $applicationVersion"
            ghr -t ${GH_TOKEN} -u ${CIRCLE_PROJECT_USERNAME} -r ${CIRCLE_PROJECT_REPONAME} -c ${CIRCLE_SHA1} -prerelease -delete ${applicationVersion}

  release-aws-private:
    executor: linux-executor
    steps:
      - checkout
      - attach_workspace:
          at: .
      - store_artifacts:
          path: release
          destination: release
      - run:
          name: prepare release
          command: |
            rm release/._* ||:
      - run:
          name: publish
          command: |
            applicationVersion=$(jq -r '.version' redisinsight/package.json)

            aws s3 cp release/ s3://${AWS_BUCKET_NAME}/private/${applicationVersion} --recursive --exclude "*.json"

  publish-prod-aws:
    executor: linux-executor
    steps:
      - checkout
      - run:
          name: Init variables
          command: |
            latestYmlFileName="latest.yml"
            downloadLatestFolderPath="public/latest"
            upgradeLatestFolderPath="public/upgrades"
            appName=$(jq -r '.productName' electron-builder.json)
            appVersion=$(jq -r '.version' redisinsight/package.json)

            echo "export downloadLatestFolderPath=${downloadLatestFolderPath}" >> $BASH_ENV
            echo "export upgradeLatestFolderPath=${upgradeLatestFolderPath}" >> $BASH_ENV
            echo "export applicationName=${appName}" >> $BASH_ENV
            echo "export applicationVersion=${appVersion}" >> $BASH_ENV
            echo "export appFileName=RedisInsight" >> $BASH_ENV

            # download latest.yml file to get last public version
            aws s3 cp s3://${AWS_BUCKET_NAME}/${downloadLatestFolderPath}/${latestYmlFileName} .

            versionLine=$(head -1 ${latestYmlFileName})
            versionLineArr=(${versionLine/:// })
            previousAppVersion=${versionLineArr[1]}

            echo "export previousApplicationVersion=${previousAppVersion}" >> $BASH_ENV

      - run:
          name: Publish AWS S3
          command: |
            # move last public version apps for download to /private/{last public version}
            aws s3 mv s3://${AWS_BUCKET_NAME}/${downloadLatestFolderPath} \
              s3://${AWS_BUCKET_NAME}/private/${previousApplicationVersion}/ --recursive

            # move last public version apps for upgrades to /private/{last public version}
            aws s3 mv s3://${AWS_BUCKET_NAME}/${upgradeLatestFolderPath} \
              s3://${AWS_BUCKET_NAME}/private/${previousApplicationVersion}/ --recursive

            # move current version apps for download to /public/latest
            aws s3 cp s3://${AWS_BUCKET_NAME}/private/${applicationVersion}/ \
              s3://${AWS_BUCKET_NAME}/${downloadLatestFolderPath} --recursive  --exclude "*.zip"

            # copy current version apps for upgrades to /public/upgrades
            aws s3 mv s3://${AWS_BUCKET_NAME}/private/${applicationVersion}/ \
              s3://${AWS_BUCKET_NAME}/${upgradeLatestFolderPath} --recursive

      - run:
          name: Add tags for all objects and create S3 metrics
          command: |

            # declare all tags
            declare -A tag0=(
                [key]='platform'
                [value]='macos'
                [objectDownload]=${applicationName}'-mac-x64.dmg'
                [objectUpgrade]=${applicationName}'.zip'
            )

            declare -A tag1=(
                [key]='platform'
                [value]='windows'
                [objectDownload]=${applicationName}'-win-installer.exe'
            )

            declare -A tag2=(
                [key]='platform'
                [value]='linux_AppImage'
                [objectDownload]=${applicationName}'-linux.AppImage'
            )

            declare -A tag3=(
                [key]='platform'
                [value]='linux_deb'
                [objectDownload]=${applicationName}'-linux.deb'
            )

            # loop for add all tags to each app and create metrics
            declare -n tag
            for tag in ${!tag@}; do

                designation0="downloads"
                designation1="upgrades"

                id0="${tag[value]}_${designation0}_${applicationVersion}"
                id1="${tag[value]}_${designation1}_${applicationVersion}"

                # add tags to each app for download
                aws s3api put-object-tagging \
                  --bucket ${AWS_BUCKET_NAME} \
                  --key ${downloadLatestFolderPath}/${tag[objectDownload]} \
                  --tagging '{"TagSet": [{ "Key": "version", "Value": "'"${applicationVersion}"'" }, {"Key": "'"${tag[key]}"'", "Value": "'"${tag[value]}"'"}, { "Key": "designation", "Value": "'"${designation0}"'" }]}'

                # add tags to each app for upgrades
                aws s3api put-object-tagging \
                  --bucket ${AWS_BUCKET_NAME} \
                  --key ${upgradeLatestFolderPath}/${tag[objectUpgrade]:=${tag[objectDownload]}} \
                  --tagging '{"TagSet": [{ "Key": "version", "Value": "'"${applicationVersion}"'" }, {"Key": "'"${tag[key]}"'", "Value": "'"${tag[value]}"'"}, { "Key": "designation", "Value": "'"${designation1}"'" }]}'

                # Create metrics for all tags for downloads to S3
                aws s3api put-bucket-metrics-configuration \
                  --bucket ${AWS_BUCKET_NAME} \
                  --id ${id0} \
                  --metrics-configuration '{"Id": "'"${id0}"'", "Filter": {"And": {"Tags": [{"Key": "'"${tag[key]}"'", "Value": "'"${tag[value]}"'"}, {"Key": "designation", "Value": "'"${designation0}"'"}, {"Key": "version", "Value": "'"${applicationVersion}"'"} ]}}}'

                # Create metrics for all tags for upgrades to S3
                aws s3api put-bucket-metrics-configuration \
                  --bucket ${AWS_BUCKET_NAME} \
                  --id ${id1} \
                  --metrics-configuration '{"Id": "'"${id1}"'", "Filter": {"And": {"Tags": [{"Key": "'"${tag[key]}"'", "Value": "'"${tag[value]}"'"}, {"Key": "designation", "Value": "'"${designation1}"'"}, {"Key": "version", "Value": "'"${applicationVersion}"'"}]}}}'

            done

workflows:
  build:
    jobs:
      # unit tests (on any commit)
      - unit-tests-ui:
          name: UTest - UI
      - unit-tests-api:
          name: UTest - API

      # integration tests run in parallel (on any commit)
      # target server runs locally to calculate code coverage
      - integration-tests-run:
          matrix:
            alias: itest-code
            parameters:
              rte: *iTestsNames
          name: ITest - << matrix.rte >> (code)
      - integration-tests-coverage:
          name: ITest - Final coverage
          requires:
            - itest-code
        # e2e tests (doesn't affect pipeline even if fail)
      - docker:
          name: Build docker image
          filters: &e2eFilter
            branches:
              only:
                - /^release.*/
                - /^e2e.*/
                - /^feature/e2e.*/
                - main
                - latest
      - e2e-tests:
          name: E2ETest
          build: docker
          filters: *e2eFilter
          requires:
            - Build docker image

      # build and release electron app (dev)
      - dev-build-approve:
          name: Build dev app
          type: approval
          requires:
            - UTest - UI
            - UTest - API
            - ITest - Final coverage
          <<: *devFilter
      - setup-sign-certificates:
          name: Setup sign certificates (dev)
          requires:
            - Build dev app
          <<: *devFilter
      - setup-build:
          name: Setup build (dev)
          env: dev
          requires:
            - Setup sign certificates (dev)
          <<: *devFilter
      - linux:
          name: Build app - Linux (dev)
          requires: &stageElectronBuildRequires
            - Setup build (dev)
          <<: *devFilter
      - macosx:
          name: Build app - MacOS (dev)
          requires: *stageElectronBuildRequires
          <<: *devFilter
      - windows:
          name: Build app - Windows (dev)
          requires: *stageElectronBuildRequires
          <<: *devFilter
      - store-build-artifacts:
          name: Store build artifacts (dev)
          requires:
            - Build app - Linux (dev)
            - Build app - MacOS (dev)
            - Build app - Windows (dev)

      # build and release electron app (stage)
      - setup-sign-certificates:
          name: Setup sign certificates (stage)
          requires:
            - UTest - UI
            - UTest - API
            - ITest - Final coverage
          <<: *stageFilter
      - setup-build:
          name: Setup build (stage)
          requires:
            - Setup sign certificates (stage)
          <<: *stageFilter
      - linux:
          name: Build app - Linux (stage)
          requires: &stageElectronBuildRequires
            - Setup build (stage)
          <<: *stageFilter
      - macosx:
          name: Build app - MacOS (stage)
          requires: *stageElectronBuildRequires
          <<: *stageFilter
      - windows:
          name: Build app - Windows (stage)
          requires: *stageElectronBuildRequires
          <<: *stageFilter
      - release-github:
          name: Release Github (stage)
          requires:
            - Build app - Linux (stage)
            - Build app - MacOS (stage)
            - Build app - Windows (stage)
      #      # integration tests over built docker image (TBD)
      #      - integration-tests-run:
      #          matrix:
      #            alias: itest-code
      #            parameters:
      #              rte: *iTestsNames
      #          name: Itest - << matrix.rte >> (code)
      # Needs approval from QA team that build was tested before merging to latest
      - qa-approve:
          name: Approved by QA team
          type: approval
          requires:
            - Release Github (stage)

      # build and release electron app (prod)
      - setup-sign-certificates:
          name: Setup sign certificates (prod)
          requires:
            - UTest - UI
            - UTest - API
            - ITest - Final coverage
          <<: *prodFilter
      - setup-build:
          name: Setup build (prod)
          env: prod
          requires:
            - Setup sign certificates (prod)
          <<: *prodFilter
      - linux:
          name: Build app - Linux (prod)
          env: prod
          requires: &prodElectronBuildRequires
            - Setup build (prod)
          <<: *prodFilter
      - macosx:
          name: Build app - MacOS (prod)
          env: prod
          requires: *prodElectronBuildRequires
          <<: *prodFilter
      - windows:
          name: Build app - Windows (prod)
          env: prod
          requires: *prodElectronBuildRequires
          <<: *prodFilter
      # virus check all electron apps (prod only)
      - virustotal:
          name: Virus check - AppImage (prod)
          ext: AppImage
          requires:
            - Build app - Linux (prod)
      - virustotal:
          name: Virus check - deb (prod)
          ext: deb
          requires:
            - Build app - Linux (prod)
      - virustotal:
          name: Virus check - dmg (prod)
          ext: dmg
          requires:
            - Build app - MacOS (prod)
      - virustotal:
          name: Virus check - exe (prod)
          ext: exe
          requires:
            - Build app - Windows (prod)

      # upload release to AWS and GitHub
      - release-aws-private:
          name: Release AWS S3 Private (prod)
          requires:
            - Virus check - AppImage (prod)
            - Virus check - deb (prod)
            - Virus check - dmg (prod)
            - Virus check - exe (prod)

      - release-github:
          name: Release Github (prod)
          env: prod
          requires:
            - Virus check - AppImage (prod)
            - Virus check - deb (prod)
            - Virus check - dmg (prod)
            - Virus check - exe (prod)

      # Manual approve for publish release
      - approve-publish:
          name: Approve Publish Release (prod)
          type: approval
          requires:
            - Release AWS S3 Private (prod)
            - Release Github (prod)
          <<: *prodFilter # double check for "latest"

      # Publish release
      - publish-prod-aws:
          name: Publish AWS S3
          requires:
            - Approve Publish Release (prod)
          <<: *prodFilter # double check for "latest"

  # Nightly tests
  nightly:
    triggers:
      - schedule:
          cron: '0 0 * * *'
          filters:
            branches:
              only:
                - main
                - latest
    jobs:
      - docker:
          name: Build docker image
      - integration-tests-run:
          matrix:
            alias: itest-docker
            parameters:
              rte: *iTestsNames
              build: ['docker']
              report: [true]
          name: ITest - << matrix.rte >> (docker)
          requires:
            - Build docker image
      - e2e-tests:
          name: E2ETest - Nightly
          build: docker
          report: true
          requires:
            - Build docker image
